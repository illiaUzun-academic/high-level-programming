# Advanced Python

* **Вступ**
  - Значення глибокого розуміння мови програмування
  - Що означає "продвинутий рівень" у контексті Python
* **PEP8 та стилізація коду**
  - Що таке PEP8 і чому він важливий
  - Основні правила стилізації коду
  - Інструменти автоматичної перевірки стилізації коду (наприклад, `flake8`)
* **Генератори**
  - Основи використання `yield`
  - Генератори для ефективної обробки даних
  - Використання yield у складних структурах
  - Використання yield from для делегування частини генератора
* **Многопоточність та асинхронність**
  - Основи многопоточності: потоки та процеси
  - Використання модулів `threading` та `multiprocessing`
  - Вступ до асинхронного програмування: `asyncio` та `aiohttp`
  - Проблеми многопоточності: гонка потоків, м'ютекси
* **Метакласи та динамічне створення класів**
  - Що таке метакласи і як їх використовувати
  - Динамічне створення класів
* **Праця з пам'яттю та оптимізація коду**
  - Основи роботи з пам'яттю в Python
  - Профілювання коду: використання `cProfile` та інших інструментів
  - Основні техніки оптимізації коду на Python
* **Кращі практики програмування на Python**
  - Організація коду та проекту
  - Використання документації та коментарів
  - Принципи "Pythonic" коду



## **Вступ**

**Значення глибокого розуміння мови програмування**

При роботі з будь-якою мовою програмування дуже важливо не лише володіти її базовими концепціями, а й розуміти глибокі особливості, які роблять цю мову унікальною. Таке розуміння дозволяє:

1. Писати більш ефективний код. Знання внутрішньої структури мови та її оптимізацій допомагає уникнути типових помилок і писати швидший код.

   Приклад:
   ```python
   # Поганий спосіб
   my_list = []
   for i in range(100000):
       my_list = my_list + [i]
   
   # Ефективний спосіб
   my_list = [i for i in range(100000)]
   ```

2. Вирішувати складніші проблеми. Володіння розширеними можливостями мови відкриває двері до рішення проблем, які важко або неможливо вирішити, використовуючи лише базові знання.

3. Бути ефективнішим у роботі. Коли ви розумієте мову на глибокому рівні, ви можете використовувати її можливості для автоматизації рутинних завдань.

---

**Що означає "продвинутий рівень" у контексті Python**

Продвинутий рівень Python не лише передбачає знання більш складних особливостей мови, але й вміння застосовувати ці знання в реальних ситуаціях.

1. **Розуміння внутрішнього функціонування Python**: Це означає знання про те, як Python обробляє пам'ять, як він виконує код під капотом тощо.

2. **Володіння складними особливостями мови**: Наприклад, метакласи, декоратори, асинхронне програмування тощо.

3. **Здатність оптимізувати код**: Не лише для швидкості, але і для споживаної пам'яті та інших ресурсів.

4. **Поглиблене розуміння стандартної бібліотеки Python**: Це допомагає реалізовувати рішення без необхідності звертатися до зовнішніх бібліотек



## **PEP8**

PEP8 - це документ, який містить конвенції щодо написання коду на Python. Його основна мета - полегшити читабельність коду, роблячи його консистентним між різними проектами. Читабельність має велике значення в Python (згадаймо принцип "Читабельність важлива" з "The Zen of Python").

1. **Читабельність**: Якщо всі розробники слідують однаковому стилю, код стає легшим для розуміння.
2. **Менше помилок**: Дотримуючись деяких стандартів, можна уникнути типових помилок.

Приклад порушення PEP8:
```python
def some_function(x,y):return x+y
```

PEP8-сумісний варіант:
```python
def some_function(x, y):
    return x + y
```

---

**Основні правила стилізації коду**

Дотримання PEP8 передбачає ряд рекомендацій:

1. **Відступи**: Використовуйте 4 пробіли на кожен рівень відступу.
2. **Довжина рядка**: Обмежуйте максимальну довжину рядка 79 символами для коду і 72 для коментарів та докстрінгів.
3. **Імпорти**: Імпорти мають бути розділені на окремі рядки і розташовані на початку файлу.
4. **Пробіли**: Використовуйте пробіли навколо операторів і після ком.

Приклад:
```python
# Погано
fruits=['apple','banana','mango']

# Добре
fruits = ['apple', 'banana', 'mango']
```

5. **Коментарі**: Коментарі повинні бути докладними і пояснювати не тільки що робить код, але, можливо, і чому.

---

**Інструменти автоматичної перевірки стилізації коду (наприклад, `flake8`)**

Є декілька інструментів, які можуть автоматично перевіряти ваш код на відповідність PEP8.

- **flake8**: Це інструмент, який перевіряє код на відповідність PEP8, а також на наявність семантичних помилок.

   Встановлення:
   ```bash
   pip install flake8
   ```

   Використання:
   ```bash
   flake8 path/to/your/code/
   ```

   `flake8` підкаже вам про всі порушення PEP8 у вашому коді.



## Генератори

**Основи використання yield**

Генератори - це тип ітераторів в Python. Головна особливість генераторів полягає в тому, що вони використовуються для "лінивої" ітерації, що дозволяє вам обробляти великі обсяги даних без необхідності завантаження їх у пам'ять повністю.

Ключове слово `yield` використовується для паузи виконання функції та повернення результату. При наступному виклику генератора виконання продовжується з того місця, де воно було припинено.

Приклад:

```python
def simple_generator():
    yield 1
    yield 2
    yield 3

gen = simple_generator()
print(next(gen))  # Виведе: 1
print(next(gen))  # Виведе: 2
print(next(gen))  # Виведе: 3
```

**Генератори для ефективної обробки даних**

Генератори дозволяють обробляти великі файли рядок за рядком, що є особливо корисним для великих датасетів.

Приклад:

```python
def read_large_file(file_path):
    with open(file_path, "r") as file:
        for line in file:
            yield line

file_gen = read_large_file("large_file.txt")
for line in file_gen:
    print(line)
```

**Використання yield у складних структурах**

`yield` може використовуватися не тільки для повернення простих значень, але й для складних структур даних.

Приклад:

```python
def nested_lists_generator():
    nested_lists = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    for sublist in nested_lists:
        for item in sublist:
            yield item

gen = nested_lists_generator()
print(list(gen))  # Виведе: [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

**Використання yield from для делегування частини генератора**

`yield from` дозволяє делегувати частину генератора іншому генератору, спрощуючи код.

Приклад:

```python
def nested_lists_generator():
    nested_lists = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    for sublist in nested_lists:
        yield from sublist

gen = nested_lists_generator()
print(list(gen))  # Виведе: [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Використання `yield from` ефективно замінює вкладений цикл у попередньому прикладі.



## Многопоточність та асинхронність

**Основи многопоточності: потоки та процеси**

Многопоточність дозволяє програмі виконувати кілька операцій одночасно. В Python існують два основних способи реалізації многопоточності: потоки (threads) та процеси (processes).

- **Потоки (Threads)**: Всі потоки ділять ту саму адресну простір пам'яті, тому доступ до змінних є спільним.
- **Процеси (Processes)**: Кожен процес має власний адресний простір пам'яті.

Приклад:

```python
import threading

def print_numbers():
    for i in range(10):
        print(i)

def print_letters():
    for letter in 'abcdefghij':
        print(letter)

# Створення потоків
t1 = threading.Thread(target=print_numbers)
t2 = threading.Thread(target=print_letters)

# Запуск потоків
t1.start()
t2.start()

# Очікування завершення потоків
t1.join()
t2.join()
```

**Використання модулів threading та multiprocessing**

Модуль `threading` дозволяє створювати потоки, а `multiprocessing` — процеси.

Приклад з `multiprocessing`:

```python
from multiprocessing import Process

def print_numbers():
    for i in range(10):
        print(i)

def print_letters():
    for letter in 'abcdefghij':
        print(letter)

# Створення процесів
p1 = Process(target=print_numbers)
p2 = Process(target=print_letters)

# Запуск процесів
p1.start()
p2.start()

# Очікування завершення процесів
p1.join()
p2.join()
```

**Вступ до асинхронного програмування: asyncio та aiohttp**

Асинхронне програмування дозволяє виконувати операції без блокування головного потоку виконання.

Приклад:

```python
import asyncio

async def print_numbers():
    for i in range(10):
        print(i)
        await asyncio.sleep(1)

async def print_letters():
    for letter in 'abcdefghij':
        print(letter)
        await asyncio.sleep(1)

# Створення event loop
loop = asyncio.get_event_loop()

# Запуск асинхронних корутин
tasks = [print_numbers(), print_letters()]
loop.run_until_complete(asyncio.gather(*tasks))
```

**Проблеми многопоточності: гонка потоків, м'ютекси**

Головна проблема многопоточності — це гонка потоків (race conditions), коли кілька потоків одночасно намагаються доступитися до одних і тих же даних.

М'ютекс (mutex) — це інструмент синхронізації, що допомагає уникнути проблем з гонкою потоків.

Приклад:

```python
import threading

counter = 0
lock = threading.Lock()

def increment_counter():
    global counter
    with lock:
        for _ in range(1000000):
            counter += 1

# Створення потоків
t1 = threading.Thread(target=increment_counter)
t2 = threading.Thread(target=increment_counter)

# Запуск потоків
t1.start()
t2.start()

# Очікування завершення потоків
t1.join()
t2.join()

print(counter)  # Має вивести 2000000
```



## Метакласи та динамічне створення класів

**Що таке метакласи і як їх використовувати**

Метаклас — це "клас класу". У Python, класи самі є об'єктами, і, так само як і інші об'єкти, класи також створені за допомогою класу. Метакласи дозволяють керувати створенням і поведінкою класів.

Приклад метакласу, який гарантує, що усі атрибути класу в верхньому регістрі:

```python
class UpperAttrMeta(type):
    def __new__(cls, name, bases, dct):
        uppercase_attrs = {
            key.upper(): value
            for key, value in dct.items() if not key.startswith('__')
        }
        return super().__new__(cls, name, bases, uppercase_attrs)

class MyClass(metaclass=UpperAttrMeta):
    attr1 = 'value1'
    attr2 = 'value2'

print(hasattr(MyClass, 'attr1'))  # False
print(hasattr(MyClass, 'ATTR1'))  # True
```

**Динамічне створення класів**

В Python можна динамічно створювати класи за допомогою функції `type()`. Ця функція приймає три аргументи:

1. Назва майбутнього класу.
2. Кортеж з базових класів.
3. Словник з атрибутами класу.

Приклад динамічного створення класу:

```python
DynamicClass = type('DynamicClass', (object,), {'attr': 'value', 'method': lambda self: 'Hello, dynamic world!'})

obj = DynamicClass()
print(obj.attr)           # value
print(obj.method())       # Hello, dynamic world!
```

Цей підхід може виявитися корисним, коли потрібно генерувати класи на льоту в залежності від різних умов чи даних.

---

Метакласи і динамічне створення класів — це потужні інструменти, які дозволяють глибоко кастомізувати поведінку класів у Python. Проте слід пам'ятати про те, що надмірне або невірне використання цих інструментів може ускладнити розуміння та підтримку коду. Пам'ятайте про принцип KISS (Keep It Simple, Stupid) і застосовуйте їх тільки тоді, коли це дійсно необхідно.



## Праця з пам'яттю та оптимізація коду

**Основи роботи з пам'яттю в Python**

В Python автоматичний менеджмент пам'яті здійснюється за допомогою механізму збору сміття. Втім, розуміння того, як пам'ять виділяється та звільняється, може допомогти оптимізувати програми та уникати витоків пам'яті.

Приклад: Використання модулю `sys` для перевірки використання пам'яті об'єктом:
```python
import sys

lst = [i for i in range(1000)]
print(sys.getsizeof(lst), "bytes")
```

**Профілювання коду: використання cProfile та інших інструментів**

cProfile — це модуль, який дозволяє профілювати виконання коду Python і отримувати статистику про час виконання функцій.

Приклад: Профілювання функції, яка рахує факторіал:
```python
import cProfile

def factorial(n):
    return 1 if n == 0 else n * factorial(n-1)

cProfile.run('factorial(10)')
```

**Основні техніки оптимізації коду на Python**

1. Використання локальних змінних: Локальні змінні працюють швидше, ніж глобальні.
2. Використання вбудованих функцій та типів: Вони оптимізовані й швидші, ніж користувацькі аналоги.
3. Використання лінивих обчислень: Генератори дозволяють обробляти дані "на льоту" та зменшити використання пам'яті.
4. Компіляція регулярних виразів, якщо їх потрібно використовувати багато разів.

Приклад оптимізації за допомогою генераторів:
```python
def large_data_processor(data):
    return (item * 2 for item in data)  # генератор

data = range(1000000)
processed_data = large_data_processor(data)
```

Робота з пам'яттю та оптимізація коду є ключовими навичками розробника. Завжди слід звертати увагу на продуктивність та ефективність коду, особливо при роботі з великими об'ємами даних або високонавантаженими системами.



## Кращі практики програмування на Python

**Організація коду та проекту**

Правильна структура проекту дозволяє швидше знаходити потрібні файли, спрощує розуміння коду і сприяє масштабованості проекту.

1. Структура директорій: Зазвичай для великих проектів використовують таку структуру:
   ```
   project_name/
   ├── package1/
   │   ├── module1.py
   │   └── module2.py
   ├── package2/
   ├── tests/
   ├── setup.py
   └── README.md
   ```

2. Файл `__init__.py`: Кожна директорія, яка визначає пакет, повинна містити файл `__init__.py`.

Приклад: Як імпортувати функції між модулями:
```python
# В module1.py
def func1():
    return "Function from module1"

# В module2.py
from package1.module1 import func1

print(func1())
```

**Використання документації та коментарів**

1. Docstrings: Використовуйте docstrings для опису модулів, функцій, класів та методів.

Приклад:
```python
def add(a, b):
    """
    Функція для додавання двох чисел.

    Parameters:
    - a (int): Перше число
    - b (int): Друге число

    Returns:
    int: Сума двох чисел
    """
    return a + b
```

2. Коментарі: Вони мають бути короткими і конкретними, щоб пояснити незрозумілий або складний участок коду.

Приклад:
```python
# Перевіряємо, чи число парне
if number % 2 == 0:
    print("Число парне")
```

**Принципи "Pythonic" коду**

1. PEP 20: Zen of Python — це набір принципів написання коду на Python. Деякі з них:
   - "Красиве краще, ніж потворне"
   - "Просте краще, ніж складне"
   - "Читабельне краще, ніж нечитабельне"

2. Прийоми "Pythonic" коду:

Приклад: Використання `enumerate` замість класичного ітерування:
```python
fruits = ['apple', 'banana', 'cherry']

# Не "pythonic"
for i in range(len(fruits)):
    print(i, fruits[i])

# "Pythonic"
for index, fruit in enumerate(fruits):
    print(index, fruit)
```

Дотримуючись цих принципів і кращих практик, ви зможете писати ефективний, читабельний та "pythonic" код.
