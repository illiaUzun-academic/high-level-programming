# Об'єктно-орієнтоване програмування в Python

* **Вступ**
  - Визначення Об'єктно-орієнтованого програмування (ООП)
  - Принципи ООП
  - Переваги та недоліки ООП
* **Основні поняття ООП**
  - Класи та об'єкти
    - Визначення класу та створення екземплярів
    - Атрибути та методи
  - Наслідування
    - Основи наслідування, базові та похідні класи
    - Перевизначення методів
  - Інкапсуляція
    - Захист атрибутів та методів (private, protected, public)
    - Геттери та сеттери
  - Поліморфізм
    - Методи з однаковими назвами в різних класах
    - Використання поліморфізму
* **Особливості ООП в Python**
  - Конструктори (`__init__`)
  - Деструктори (`__del__`)
  - Магічні методи (`__str__`, `__repr__`, `__add__` тощо)
  - Декоратори для властивостей (`@property`, `@setter`, `@deleter`)
* **Композиція та агрегація**
  - Відмінності між композицією та агрегацією
  - Приклади композиції та агрегації в Python
* **Продвинуті аспекти ООП в Python**
  - Абстрактні класи та методи
  - Міксіни
  - Статичні методи (`@staticmethod`) та методи класу (`@classmethod`)
* **Дизайн патерни**
  - Що таке дизайн патерни і чому вони важливі
  - Приклади реалізації популярних патернів в Python (Singleton, Factory, Observer тощо)
* **Висновок**
  - Як використовувати ООП ефективно в Python



Вступ
---

1. **Визначення Об'єктно-орієнтованого програмування (ООП)**
Об'єктно-орієнтоване програмування (ООП) - це парадигма програмування, що базується на концепції "об'єктів", які можуть містити дані в формі полів (часто відомих як атрибути) та код в формі процедур (відомих як методи).

```python
class Human:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def introduce(self):
        print(f"Привіт! Мене звати {self.name} і мені {self.age} років.")
```

2. **Принципи ООП**
   - **Інкапсуляція**: Зберігання даних та методів, які працюють з цими даними, в одному місці.
   - **Наслідування**: Можливість створювати новий клас на базі існуючого.
   - **Поліморфізм**: Можливість об'єктів з різними типами обробляти дані різним чином.
   - **Абстракція**: Виділення ключового набору аспектів об'єкта, відкидуючи неважливі деталі.

3. **Переваги та недоліки ООП**

**Переваги**:
   - **Модульність**: Програма розбивається на менші підмодулі (класи), що спрощує розробку та тестування.
   - **Повторне використання коду**: Завдяки наслідуванню можна використовувати вже існуючий код.
   - **Гнучкість**: Легко вносити зміни в систему, розширюючи чи модифікуючи класи.

```python
class Animal:
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "Гав!"

class Cat(Animal):
    def speak(self):
        return "М'яу!"
```

**Недоліки**:
   - **Ускладнення**: Для простих завдань ООП може виявитися занадто складним.
   - **Повільніша виконавча швидкість**: Об'єкти зазвичай споживають більше пам'яті й вимагають більше обчислювальних ресурсів.



Основні поняття ООП
---

1. **Класи та об'єкти**

   - **Визначення класу та створення екземплярів**

     Клас - це "шаблон" або "зразок", що визначає можливі стани та поведінку об'єкта. Об'єкт - це конкретний екземпляр класу.

     ```python
     class Car:
         pass

     my_car = Car()  # Створення екземпляра класу Car
     ```

   - **Атрибути та методи**

     Атрибути - це змінні класу, що містять інформацію про стан об'єкта. Методи - це функції класу, що визначають поведінку об'єкта.

     ```python
     class Car:
         def __init__(self, brand, model):
             self.brand = brand  # атрибут
             self.model = model  # атрибут
      
         def display_info(self):  # метод
             print(f"Це {self.brand} моделі {self.model}.")
      
     my_car = Car("Toyota", "Corolla")
     my_car.display_info()  # Виведе: "Це Toyota моделі Corolla."
     ```

2. **Наслідування**

   - **Основи наслідування, базові та похідні класи**

     Наслідування дозволяє створити новий клас на основі вже існуючого (базового) класу. Новий клас називається похідним.

     ```python
     class Vehicle:
         def __init__(self, wheels):
             self.wheels = wheels

     class Car(Vehicle):
         def __init__(self, brand, model):
             super().__init__(wheels=4)
             self.brand = brand
             self.model = model
     ```

   - **Перевизначення методів**

     Похідний клас може перевизначити методи базового класу.

     ```python
     class Animal:
         def speak(self):
             return "..."
      
     class Dog(Animal):
         def speak(self):
             return "Гав!"
      
     rex = Dog()
     print(rex.speak())  # Виведе: "Гав!"
     ```

3. **Інкапсуляція**

   - **Захист атрибутів та методів (private, protected, public)**

     В Python є три рівня доступу до атрибутів та методів:

     - `public`: доступний з будь-якого місця
     - `protected`: позначається одним підкресленням перед іменем (напр., `_attribute`). Він рекомендований для внутрішнього використання в класах та їх нащадках.
     - `private`: позначається двома підкресленнями перед іменем (напр., `__attribute`). Це робить атрибут або метод недоступним ззовні класу.

     ```python
     class Example:
         def __init__(self):
             self.public_var = "Public"
             self._protected_var = "Protected"
             self.__private_var = "Private"
     ```

   - **Геттери та сеттери**

     Для доступу до приватних атрибутів та їх зміни використовуються спеціальні методи: геттери (для отримання значення) та сеттери (для встановлення нового значення).

     ```python
     class Circle:
         def __init__(self, radius):
             self.__radius = radius
      
         @property
         def radius(self):
             return self.__radius
      
         @radius.setter
         def radius(self, value):
             if value > 0:
                 self.__radius = value
             else:
                 print("Радіус повинен бути позитивним!")
     ```

4. **Поліморфізм**

   - **Методи з однаковими назвами в різних класах**

     Поліморфізм дозволяє використовувати об'єкти різних класів з однаковим інтерфейсом без знання про тип об'єкта.

     ```python
     class Dog:
         def speak(self):
             return "Гав!"

     class Cat:
         def speak(self):
             return "М'яу!"

     def animal_speak(animal):
         print(animal.speak())

     rex = Dog()
     whiskers = Cat()

     animal_speak(rex)      # Виведе: "Гав!"
     animal_speak(whiskers) # Виведе: "М'яу!"
     ```

   - **Використання поліморфізму**

     Поліморфізм корисний, коли вам потрібно працювати з різними типами даних, які мають спільний інтерфейс.

     ```python
     class Rectangle:
         def area(self, length, width):
             return length * width
     
     class Circle:
         def area(self, radius):
             return 3.14 * radius * radius
     
     def find_area(shape, *args):
         print(shape.area(*args))
     
     rect = Rectangle()
     circ = Circle()
     
     find_area(rect, 10, 5) # Виведе: 50
     find_area(circ, 7)     # Виведе приблизно: 153.86
     ```



Особливості ООП в Python
---

1. **Конструктори (`__init__`)**
   
   Конструктор - це спеціальний метод, який автоматично викликається під час створення екземпляра класу.

   ```python
   class Car:
       def __init__(self, brand, model):
           self.brand = brand
           self.model = model
   ```

   Тут `__init__` є конструктором, який приймає `brand` та `model` як параметри та ініціалізує атрибути об'єкта.

2. **Деструктори (`__del__`)**
   
   Деструктор - це спеціальний метод, який викликається, коли об'єкт знищується.

   ```python
   class Example:
       def __del__(self):
           print("Об'єкт буде знищено!")
   
   obj = Example()
   del obj  # Виведе: "Об'єкт буде знищено!"
   ```

3. **Магічні методи (`__str__`, `__repr__`, `__add__` тощо)**
   
   Магічні методи дозволяють визначати поведінку об'єктів в різних ситуаціях.

   - `__str__`: Повертає рядкове представлення об'єкта.
     
     ```python
     class Person:
         def __init__(self, name):
             self.name = name
     
         def __str__(self):
             return self.name
     
     person = Person("Alex")
     print(person)  # Виведе: "Alex"
     ```

   - `__repr__`: Повертає "офіційне" рядкове представлення об'єкта.

     ```python
     class Person:
         def __init__(self, name):
             self.name = name

         def __repr__(self):
             return f"Person('{self.name}')"

     person = Person("Alex")
     print(repr(person))  # Виведе: "Person('Alex')"
     ```

   - `__add__`: Дозволяє використовувати оператор `+` з об'єктами.
     
     ```python
     class Number:
         def __init__(self, value):
             self.value = value
     
         def __add__(self, other):
             return self.value + other.value
     
     a = Number(5)
     b = Number(3)
     print(a + b)  # Виведе: 8
     ```

4. **Декоратори для властивостей (`@property`, `@setter`, `@deleter`)**

   Декоратори для властивостей дозволяють нам керувати доступом до атрибутів класу, роблячи його безпечнішим та інкапсульованим.

   Давайте розглянемо клас `Temperature`, який має атрибут `_celsius`. Ми хочемо, щоб користувач міг отримувати температуру в градусах Цельсія і Фаренгейта, а також встановлювати температуру в градусах Цельсія:
   
   ```python
   class Temperature:
       def __init__(self, celsius=0):
           self._celsius = celsius
   
       @property
       def celsius(self):
           return self._celsius
   
       @celsius.setter
       def celsius(self, value):
           self._celsius = value
   
       @property
       def fahrenheit(self):
           return self._celsius * 9/5 + 32
   
       @fahrenheit.setter
       def fahrenheit(self, value):
           self._celsius = (value - 32) * 5/9
   
       @celsius.deleter
       def celsius(self):
           print("Значення температури в градусах Цельсія видалено!")
           del self._celsius
   ```
   
   Використання:
   
   ```python
   temp = Temperature(25)
   
   print(temp.celsius)    # Виведе: 25
   print(temp.fahrenheit) # Виведе: 77.0
   
   temp.fahrenheit = 86
   print(temp.celsius)    # Виведе: 30
   
   del temp.celsius       # Виведе: "Значення температури в градусах Цельсія видалено!"
   ```
   
   У цьому прикладі:
   
   1. `@property` дозволяє нам отримувати значення атрибуту `_celsius` через метод `celsius()` і значення в градусах Фаренгейта через метод `fahrenheit()`.
   2. `@celsius.setter` і `@fahrenheit.setter` дозволяють нам встановлювати значення `_celsius` безпосередньо або шляхом конвертації з Фаренгейта.
   3. `@celsius.deleter` дозволяє нам видаляти атрибут `_celsius`, виводячи повідомлення при його видаленні.



Композиція та агрегація
---

**Відмінності між композицією та агрегацією**

*Композиція* та *агрегація* - це два основних способи взаємодії між класами в Об'єктно-орієнтованому програмуванні.

1. **Агрегація** відбувається, коли один клас включає в себе інший як частину. Основний клас може існувати незалежно від агрегованого.
2. **Композиція** - це вид агрегації, коли основний клас відповідає за життєвий цикл залежного класу. Якщо основний клас буде знищений, то і залежний клас теж буде знищений.

**Приклади композиції та агрегації в Python**

1. **Агрегація**:

Розглянемо приклад автомобіля і двигуна. Автомобіль може існувати без двигуна, і двигун може існувати окремо від автомобіля.

```python
class Engine:
    def __init__(self, type_="Бензин"):
        self.type = type_

class Car:
    def __init__(self, engine):
        self.engine = engine

benz_engine = Engine(type_="Бензин")
my_car = Car(benz_engine)

print(my_car.engine.type)  # Виведе: Бензин
```

У цьому прикладі, якщо автомобіль `my_car` буде знищений, двигун `benz_engine` все ще буде існувати.

2. **Композиція**:

Розглянемо приклад книги та її сторінок. Книга складається зі сторінок, і якщо книгу знищити, її сторінки теж будуть знищені.

```python
class Page:
    def __init__(self, content=""):
        self.content = content

class Book:
    def __init__(self):
        self.pages = [Page(content=str(i)) for i in range(1, 101)]

    def get_page_content(self, number):
        return self.pages[number-1].content

my_book = Book()
print(my_book.get_page_content(50))  # Виведе: 50
```

У цьому прикладі, якщо `my_book` буде знищена, її `pages` також будуть знищені, тому що вони є частиною об'єкта `my_book`.

Важливо зрозуміти, коли застосовувати агрегацію, а коли композицію. Якщо один об'єкт є фізичною частиною або є нерозривно пов'язаний з іншим об'єктом, слід використовувати композицію. У всіх інших випадках слід використовувати агрегацію.



Продвинуті аспекти ООП в Python
---

**Абстрактні класи та методи**

*Абстрактний клас* - це клас, який не може бути інстанційований напряму. Він призначений для успадкування та має хоча б один абстрактний метод.

*Абстрактний метод* - це метод, оголошений в абстрактному класі, але без реалізації. Підкласи, які успадковують абстрактний клас, повинні надати реалізацію цьому методу.

```python
from abc import ABC, abstractmethod

class AbstractClass(ABC):

    @abstractmethod
    def do_something(self):
        pass

class ConcreteClass(AbstractClass):

    def do_something(self):
        print("Реалізація методу в конкретному класі.")

# obj = AbstractClass()  # Це викличе помилку, так як не можна створити екземпляр абстрактного класу
obj2 = ConcreteClass()
obj2.do_something()  # Виведе: Реалізація методу в конкретному класі.
```

**Міксіни**

*Міксіни* - це особливі класи, які надають додаткові можливості для інших класів, але не призначені для самостійного використання. Вони дозволяють додавати функціональність до класів без використання множинного наслідування.

```python
class JsonMixin:
    def to_json(self):
        import json
        return json.dumps(self.__dict__)

class Person(JsonMixin):
    def __init__(self, name, age):
        self.name = name
        self.age = age

person = Person("Олексій", 30)
print(person.to_json())  # Виведе: {"name": "Олексій", "age": 30}
```

**Статичні методи (@staticmethod) та методи класу (@classmethod)**

*Статичний метод* це метод, який не вимагає доступу до атрибутів класу або екземпляра. Він може бути викликаний на рівні класу.

*Метод класу* працює з класом, а не екземпляром. Він приймає першим аргументом сам клас, зазвичай позначається як `cls`.

```python
class MyClass:

    class_variable = "Класова змінна"

    @staticmethod
    def static_method():
        return "Це статичний метод"

    @classmethod
    def class_method(cls):
        return f"Це метод класу. Він має доступ до {cls.class_variable}"

print(MyClass.static_method())  # Виведе: Це статичний метод
print(MyClass.class_method())   # Виведе: Це метод класу. Він має доступ до Класова змінна
```

**Множинне наслідування в Python**

Множинне наслідування дозволяє класу успадковувати властивості та методи з більш ніж одного базового класу. Це може бути корисним у певних ситуаціях, але також може призвести до комплексності і плутанини, якщо не використовується обережно. Під час використання множинного наслідування важливо бути обережним і чітко розуміти порядок, в якому методи будуть викликані, щоб уникнути несподіваних результатів.

Ось приклад множинного наслідування:

```python
class A:
    def method_from_class_a(self):
        return "Метод з класу A"

class B:
    def method_from_class_b(self):
        return "Метод з класу B"

class C(A, B):
    pass

obj = C()
print(obj.method_from_class_a())  # Виведе: Метод з класу A
print(obj.method_from_class_b())  # Виведе: Метод з класу B
```

**Повернення декількох змінних з функції чи метода**

В Python, функція або метод може повертати декілька значень у вигляді кортежу. Також ці значення можна розпакувати в декілька змінних.

Приклад:

```python
def multiple_values():
    return "Аліса", 25, "програміст"

name, age, profession = multiple_values()

print(name)        # Виведе: Аліса
print(age)         # Виведе: 25
print(profession)  # Виведе: програміст
```

Ви можете також повернути значення у вигляді списку, словника або будь-якої іншої структури даних, але кортеж є найзвичайнішим способом для цієї мети.



## Дизайн патерни

Дизайн патерни - це перевірені часом рішення для поширених проблем програмування. Вони можуть вважатися "шаблонами", які можна застосувати до певної проблеми в конкретному контексті.

**Що таке дизайн патерни і чому вони важливі**

1. **Стандартне рішення**: Патерни надають перевірені рішення для поширених проблем, тож програмісти можуть використовувати їх замість "винаходу велосипеда".
2. **Читабельність**: Оскільки багато розробників знають дизайн патерни, це спрощує процес розуміння коду.
3. **Повторне використання коду**: Патерни можуть бути адаптовані і використані в різних проектах без значних змін.

**Приклади реалізації популярних патернів в Python** 

1. **Singleton** - гарантує, що клас має лише один екземпляр і надає точку доступу до цього екземпляра.

   ```python
   class Singleton:
       _instance = None

       def __new__(cls):
           if cls._instance is None:
               cls._instance = super().__new__(cls)
           return cls._instance

   first_instance = Singleton()
   second_instance = Singleton()

   print(first_instance is second_instance)  # True
   ```

2. **Factory** - використовується для створення об'єктів без вказівки конкретного класу об'єкта.

   ```python
   class Dog:
       def speak(self):
           return "Гав"

   class Cat:
       def speak(self):
           return "М'яу"

   def get_pet(pet="dog"):
       pets = dict(dog=Dog(), cat=Cat())
       return pets[pet]

   d = get_pet("dog")
   print(d.speak())  # Гав

   c = get_pet("cat")
   print(c.speak())  # М'яу
   ```

3. **Observer** - дозволяє об'єкту публікувати зміни свого стану, щоб інші об'єкти могли відгукнутися на ці зміни.

   ```python
   class Observer:
       def update(self, message: str) -> None:
           raise NotImplementedError
   
   class User(Observer):
       def update(self, message: str) -> None:
           print(f'User received: {message}')
   
   class Notification:
       def __init__(self):
           self._observers = []
   
       def register(self, observer: Observer) -> None:
           self._observers.append(observer)
   
       def notify_all(self, message: str) -> None:
           for observer in self._observers:
               observer.update(message)
   
   notification = Notification()
   user = User()
   notification.register(user)
   notification.notify_all("New update available!")
   ```



## Висновок

**Як використовувати ООП ефективно в Python**

1. **Чітко визначайте свої класи**: Кожен клас повинен мати конкретну мету. Якщо ви виявляєте, що ваш клас робить занадто багато різних речей, розгляньте можливість його розбиття на декілька класів.

   ```python
   # Добре
   class Car:
       def drive(self):
           pass
   
   class Repair:
       def fix_car(self, car):
           pass
   
   # Погано
   class Car:
       def drive(self):
           pass

       def fix_car(self):
           pass
   ```

2. **Використовуйте композицію та агрегацію, де це доречно**: Якщо ви можете використовувати композицію замість наслідування, це часто буде кращим рішенням.

   ```python
   class Engine:
       pass

   class Car:
       def __init__(self):
           self.engine = Engine()
   ```

3. **Не зловживайте множинним наслідуванням**: Хоча Python підтримує множинне наслідування, воно може призвести до складностей у визначенні, який метод або атрибут використовується.

4. **Дотримуйтесь принципів SOLID**: Ці п'ять основних принципів ООП допоможуть вам писати більш модульний та зрозумілий код.



## SOLID

### **S — Принцип єдиної відповідальності (Single Responsibility Principle, SRP)**

Цей принцип заснований на ідеї, що кожен клас повинен мати лише одну причину для зміни. Сказано інакше, кожен клас повинен мати лише одну відповідальність. Коли клас має більше ніж одну відповідальність, він стає більш хитким, більш вразливим до змін та більш важким для підтримки.

**Приклад:**

Уявімо систему управління повідомленнями:

```python
# Погано
class Message:
    def send_email(self, content, recipient):
        # Код для відправки електронної пошти

    def save_to_database(self, content):
        # Код для збереження повідомлення в базу даних
```

У цьому прикладі клас `Message` відповідає як за відправку електронних листів, так і за збереження повідомлень в базу даних. Такий підхід порушує SRP, тому що є дві причини для зміни цього класу: зміни в способі відправки електронної пошти та зміни в способі збереження повідомлень.

```python
# Добре
class EmailSender:
    def send_email(self, content, recipient):
        # Код для відправки електронної пошти

class MessageDatabase:
    def save_to_database(self, content):
        # Код для збереження повідомлення в базу даних
```

Тепер ми маємо два класи, кожен з яких має лише одну відповідальність. Якщо ми захочемо змінити спосіб відправки електронної пошти, нам потрібно буде внести зміни тільки в клас `EmailSender`. Це робить наш код більш гнучким, менш вразливим до змін і легшим для підтримки.

**Пояснення:**

Коли клас дотримується принципу єдиної відповідальності, його легше розуміти, модифікувати, рефакторити та тестувати. Навпаки, коли клас має декілька відповідальностей, він стає більш комплексним, що може призвести до додаткових помилок та збільшення вартості змін.

Тому завжди важливо стежити за тим, щоб ваши класи були спрямовані на одну конкретну відповідальність, що робить ваш код чистішим, більш модульним та легшим для підтримки.

### **O — Принцип відкритості/закритості (Open/Closed Principle, OCP)**

Згідно цього принципу, програмний код (класи, модулі, функції) повинен бути відкритим для розширення, але закритим для модифікації. Це означає, що поведінка модуля може бути розширена без зміни його джерельного коду.

**Приклад:**

Уявімо, що у нас є система фільтрації продуктів за різними критеріями:

```python
class Product:
    def __init__(self, color, size):
        self.color = color
        self.size = size

class ProductFilter:
    def filter_by_color(self, products, color):
        return [product for product in products if product.color == color]

    def filter_by_size(self, products, size):
        return [product for product in products if product.size == size]
```

Що якщо ми захочемо додати новий критерій фільтрації, наприклад, за формою? В цьому випадку нам потрібно буде модифікувати клас `ProductFilter`, порушуючи OCP.

Ми можемо покращити це, використовуючи специфікації:

```python
from abc import ABC, abstractmethod

class Specification(ABC):
    @abstractmethod
    def is_satisfied(self, item):
        pass

class Filter(ABC):
    @abstractmethod
    def filter(self, items, spec):
        pass

class ColorSpecification(Specification):
    def __init__(self, color):
        self.color = color

    def is_satisfied(self, item):
        return item.color == self.color

class SizeSpecification(Specification):
    def __init__(self, size):
        self.size = size

    def is_satisfied(self, item):
        return item.size == self.size
    
class BetterFilter(Filter):
    def filter(self, items, spec):
        return [item for item in items if spec.is_satisfied(item)]
```

Зараз, якщо ми захочемо додати новий критерій фільтрації, нам просто потрібно створити нову специфікацію, не змінюючи існуючий код.

**Пояснення:**

Принцип відкритості/закритості допомагає уникнути проблем, пов'язаних із змінами в існуючому коді. Це забезпечує гнучкість архітектури, дозволяючи легко додавати нові функції без ризику внесення помилок в існуючий код. При цьому забезпечується стабільність системи на протязі її еволюції.

### **L — Принцип підстановки Барбари Лісков (Liskov Substitution Principle, LSP)**

Цей принцип стверджує, що об'єкти базового класу завжди повинні мати можливість бути заміненими на об'єкти підкласів без втрати коректності програми. Скоро кажучи, підкласи повинні доповнювати, а не змінювати поведінку базових класів.

**Приклад:**

Погляньмо на класичний приклад з прямокутниками та квадратами:

```python
class Rectangle:
    def __init__(self, width, height):
        self._width = width
        self._height = height

    @property
    def width(self):
        return self._width

    @width.setter
    def width(self, value):
        self._width = value

    @property
    def height(self):
        return self._height

    @height.setter
    def height(self, value):
        self._height = value

    def area(self):
        return self._width * self._height

class Square(Rectangle):
    def __init__(self, size):
        super().__init__(size, size)

    @Rectangle.width.setter
    def width(self, value):
        self._width = value
        self._height = value

    @Rectangle.height.setter
    def height(self, value):
        self._width = value
        self._height = value
```

На перший погляд може здатися, що квадрат є підтипом прямокутника і він може успадковувати його поведінку. Проте цей код порушує LSP. Якщо ми спробуємо змінити ширину або висоту квадрата (який є підтипом прямокутника), ми неочікувано змінимо і інший розмір.

**Пояснення:**

Принцип підстановки Барбари Лісков говорить про важливість забезпечення збереження очікуваного поведінки при наслідуванні і розширенні класів. Якщо підклас змінює поведінку базового класу таким чином, що він перестає відповідати очікуванням, це може призвести до неочікуваних помилок у програмі.

Дотримуючись LSP, ми можемо бути впевнені, що розширення та модифікація системи не призведе до непередбачуваних наслідків, і код буде більш зрозумілим і надійним.

### **I — Принцип розділення інтерфейсу (Interface Segregation Principle, ISP)**

Цей принцип говорить про те, що клієнти не повинні бути зобов'язаними залежати від інтерфейсів, які вони не використовують. Іншими словами, замість одного "всеохоплюючого" інтерфейсу краще мати декілька специфічних.

**Приклад:**

Припустимо, у нас є інтерфейс "Робочий", який містить методи для різних типів робіт:

```python
class Worker:
    def work(self):
        pass

    def eat(self):
        pass
```

Якщо у нас є робот, він може виконувати роботу, але він не їсть. Тому наш інтерфейс не є оптимальним для робота:

```python
class Robot(Worker):
    def work(self):
        # do robot's work
        pass

    def eat(self):
        # Robots don't eat!
        pass
```

Тут краще розділити інтерфейс на два:

```python
class Workable:
    def work(self):
        pass

class Eatable:
    def eat(self):
        pass
```

Тепер наш Robot може імплементувати тільки те, що йому потрібно:

```python
class Robot(Workable):
    def work(self):
        # do robot's work
        pass
```

**Пояснення:**

Принцип розділення інтерфейсу допомагає зробити систему гнучкою і легко адаптованою до змін. Якщо інтерфейси маленькі та специфічні, вони легше адаптуються і реалізуються. Крім того, це зменшує ризик впливу змін в одній частині системи на інші частини.

Дотримуючись ISP, ми робимо наш код чіткішим, менше залежним та більш гнучким для розширення та модифікації.

### **D — Принцип інверсії залежностей (Dependency Inversion Principle, DIP)**

Цей принцип визначає два основних пункти:

1. Високорівневі модулі не повинні залежати від низькорівневих модулів. Обидва повинні залежати від абстракцій.
2. Абстракції не повинні залежати від деталей. Деталі повинні залежати від абстракцій.

У сутності це означає, що для створення гнучкої системи потрібно використовувати інтерфейси та абстрактні класи так, щоб можна було легко змінювати взаємодію між компонентами без зміни їхньої внутрішньої логіки.

**Приклад:**

Розглянемо систему, де є різні способи збереження даних (у файлах, в базі даних тощо). Замість того, щоб прямо залежати від конкретних реалізацій, ми можемо використовувати інтерфейс:

```python
from abc import ABC, abstractmethod

class DataStorage(ABC):

    @abstractmethod
    def store(self, data):
        pass

class FileStorage(DataStorage):
    
    def store(self, data):
        # logic to store data in a file
        pass

class DatabaseStorage(DataStorage):
    
    def store(self, data):
        # logic to store data in a database
        pass
```

Тепер, якщо у нас є сервіс, який використовує цю систему збереження, він може працювати з будь-якою реалізацією, яка дотримується інтерфейсу `DataStorage`:

```python
class DataService:
    def __init__(self, storage: DataStorage):
        self._storage = storage
        
    def save_data(self, data):
        self._storage.store(data)
```

Таким чином, якщо ми змінимо спосіб зберігання даних (наприклад, з файлу на базу даних), нам потрібно буде змінити лише те місце, де ми ініціалізуємо конкретний об'єкт зберігання, а не всю логіку сервісу.

**Пояснення:**

DIP допомагає забезпечити розділення відповідальності у вашому коді, роблячи модулі менш залежними один від одного. Це сприяє тому, що зміни в одному модулі не призводять до каскадних змін у інших модулях, що робить систему більш стійкою до змін та легше підтримуваною.