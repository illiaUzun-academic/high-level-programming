# Моделі і база даних

1. **Вступ**
   - Загальна концепція моделей в Django.
   - Як моделі відображаються на структуру бази даних.
2. **Основи створення моделей**
   - Поля моделей та їх типи (CharField, IntegerField, DateField тощо).
   - Атрибути полів: `max_length`, `null`, `blank`, `choices` та інші.
   - Встановлення `primary_key` і `ForeignKey` для зв'язків між таблицями.
3. **Зв'язки між моделями**
   - ForeignKey - зв'язок "багато до одного".
   - OneToOneField - зв'язок "один до одного".
   - ManyToManyField - зв'язок "багато до багатьох".
4. **Метадані моделі**
   - Внутрішній клас `Meta`: налаштування ім'я таблиці, порядку сортування тощо.
   - Використання `verbose_name` та `verbose_name_plural` для уточнення назв.
5. **Міграції**
   - Що таке міграції і як вони працюють.
   - Команди `makemigrations` та `migrate`.
   - Застосування та відкат міграцій.
6. **Робота з базою даних через Django ORM**
   - Створення, вибірка, оновлення та видалення записів за допомогою ORM.
   - Використання методів `filter`, `exclude`, `get`, `all` тощо.
   - Ланцюжкові запити до бази даних.
7. **Оптимізація запитів до бази даних**
   - Використання `select_related` та `prefetch_related` для зменшення кількості запитів.
   - Інші прийоми оптимізації: злиття запитів, використання `values` та `values_list`.
8. **Додаткові можливості моделей**
   - Створення власних менеджерів та запитів.
   - Оверрайдінг методів моделі: `save`, `delete` та інші.



### Вступ

#### Загальна концепція моделей в Django.
Django - це фреймворк, який використовує підхід "Don’t Repeat Yourself" (DRY) і прагне автоматизувати багато звичних задач розробки. Однією з ключових особливостей Django є його ORM (Object-Relational Mapping) система. ORM дозволяє нам працювати з базами даних, так ніби ми працюємо з об'єктами Python.

У Django, модель - це Python клас, який представляє таблицю в базі даних. Атрибути класу представляють стовпці таблиці. Коли ми створюємо модель, Django надає API для роботи з даною таблицею.

#### Як моделі відображаються на структуру бази даних.
Кожна модель Django відображається на таблицю в базі даних. Для прикладу, якщо у нас є модель `Book`, то в базі даних буде таблиця `book`. Кожен атрибут цієї моделі стане стовпцем у відповідній таблиці.

Давайте розглянемо наступний код:
```python
from django.db import models

class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.CharField(max_length=100)
    published_date = models.DateField()
```

Тут у нас є модель `Book` із трема атрибутами: `title`, `author`, `published_date`. Коли ми застосуємо міграції, Django створить таблицю `book` із трьома стовпцями: `title`, `author` і `published_date`.

Окрім цього, Django автоматично додає поле `id` до кожної моделі, яке служить як первинний ключ (Primary Key) для таблиці.



### Основи створення моделей

#### Поля моделей та їх типи (CharField, IntegerField, DateField тощо).

В Django, для представлення різних типів даних в базі даних, використовуються різні типи полів. Ось деякі з основних типів полів:

- **CharField**: для коротких текстових рядків. Потребує параметр `max_length`, який визначає максимальну довжину текстового рядка.
  
  ```python
  name = models.CharField(max_length=100)
  ```

- **IntegerField**: для цілих чисел.
  
  ```python
  age = models.IntegerField()
  ```

- **DateField**: для дат.
  
  ```python
  birth_date = models.DateField()
  ```

Існують багато інших типів полів, таких як FloatField, EmailField, ImageField тощо, які дозволяють представляти різноманітні типи даних у вашому додатку.

#### Атрибути полів: `max_length`, `null`, `blank`, `choices` та інші.

Кожне поле може мати різні атрибути, які дозволяють налаштувати його поведінку:

- **max_length**: Визначає максимальну довжину текстового рядка для CharField.
  
- **null**: Якщо встановлено в `True`, поле може бути пустим у базі даних.
  
- **blank**: Якщо встановлено в `True`, поле може бути пустим у формах.
  
- **choices**: Визначає набір варіантів для поля. Зазвичай використовується для створення випадаючих списків у формах.
  
  ```python
  GENDER_CHOICES = (
      ('M', 'Чоловічий'),
      ('F', 'Жіночий'),
  )
  gender = models.CharField(max_length=1, choices=GENDER_CHOICES)
  ```

#### Встановлення `primary_key` і `ForeignKey` для зв'язків між таблицями.

Кожна модель в Django автоматично отримує поле `id`, яке служить як первинний ключ (Primary Key). Проте, якщо вам потрібно вказати свій первинний ключ, ви можете використовувати атрибут `primary_key`.

```python
custom_id = models.IntegerField(primary_key=True)
```

Для створення зв'язків між моделями використовуються поля, такі як `ForeignKey`. Це дозволяє створити зв'язок "багато до одного" між двома моделями.

```python
class Author(models.Model):
    name = models.CharField(max_length=100)

class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.ForeignKey(Author, on_delete=models.CASCADE)
```

У цьому прикладі, кожна книга (`Book`) пов'язана з одним автором (`Author`), але кожен автор може мати багато книг.



### Зв'язки між моделями

Для представлення взаємозв'язків між таблицями в базі даних Django пропонує декілька типів полів.

#### ForeignKey - зв'язок "багато до одного".

`ForeignKey` використовується, коли у нас є зв'язок "багато до одного" між двома моделями.

Припустимо, у нас є дві моделі: `Author` та `Book`. Один автор може написати багато книг, але кожна книга має лише одного автора.

```python
class Author(models.Model):
    name = models.CharField(max_length=100)

class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.ForeignKey(Author, on_delete=models.CASCADE)
```

Тут, поле `author` в моделі `Book` є `ForeignKey`, яке посилається на модель `Author`.

#### OneToOneField - зв'язок "один до одного".

`OneToOneField` використовується, коли у нас є строгий зв'язок "один до одного" між двома моделями.

Припустимо, у нас є модель `User`, і ми хочемо зберігати додаткову інформацію про кожного користувача в моделі `UserProfile`.

```python
class User(models.Model):
    username = models.CharField(max_length=100)
    email = models.EmailField()

class UserProfile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    date_of_birth = models.DateField()
```

Тут, кожен `User` може мати лише один `UserProfile`.

#### ManyToManyField - зв'язок "багато до багатьох".

`ManyToManyField` використовується, коли об'єкт з однієї моделі може бути пов'язаний з декількома об'єктами з іншої моделі і навпаки.

Розглянемо приклад з моделями `Student` та `Course`. Один студент може вивчати декілька курсів, і один курс може мати декілька студентів.

```python
class Student(models.Model):
    name = models.CharField(max_length=100)

class Course(models.Model):
    title = models.CharField(max_length=100)
    students = models.ManyToManyField(Student)
```

Тут, поле `students` в моделі `Course` є `ManyToManyField`, яке посилається на модель `Student`.



### Метадані моделі

Коли ми створюємо моделі у Django, додаткова інформація та налаштування часто потрібні для коректної роботи з цими моделями. Ця інформація називається метаданими моделі.

#### Внутрішній клас `Meta`: налаштування ім'я таблиці, порядку сортування тощо.

Внутрішній клас `Meta` використовується для визначення метаданих моделі. Давайте розглянемо приклад:

```python
class Book(models.Model):
    title = models.CharField(max_length=100)
    publication_date = models.DateField()

    class Meta:
        ordering = ['publication_date']
        db_table = 'custom_book_table'
```

Тут, за допомогою `ordering`, ми вказали, що за замовчуванням книги повинні бути відсортовані за датою публікації. А `db_table` вказує, що в базі даних ця модель повинна використовувати таблицю з ім'ям "custom_book_table" замість стандартного імені, яке Django створило б для нас.

#### Використання `verbose_name` та `verbose_name_plural` для уточнення назв.

Іноді потрібно зазначити зрозуміле ім'я для моделі або її полів, особливо коли воно використовується в адміністративному інтерфейсі Django. Для цього ми можемо використовувати `verbose_name` і `verbose_name_plural`.

```python
class Book(models.Model):
    title = models.CharField(max_length=100, verbose_name="Назва книги")
    
    class Meta:
        verbose_name = "Книга"
        verbose_name_plural = "Книги"
```

Тут, для поля `title` ми встановили `verbose_name` як "Назва книги". Також ми встановили `verbose_name` для самої моделі як "Книга", і `verbose_name_plural` як "Книги".



### Міграції

Міграції є дуже важливою частиною роботи з Django, дозволяючи нам змінювати структуру бази даних без втрати даних.

#### Що таке міграції і як вони працюють.

Міграції - це спосіб Django відстежувати зміни в моделях та застосовувати їх до структури бази даних. Вони як версійний контроль для вашої бази даних. Коли ви змінюєте модель (наприклад, додаєте поле), ви створюєте міграцію, яка описує ці зміни. Після цього ви "застосовуєте" міграцію, і Django змінює структуру бази даних відповідно до описаних у міграції змін.

#### Команди `makemigrations` та `migrate`.

Коли ви внесете зміни до своєї моделі, вам потрібно створити нову міграцію. Це можна зробити за допомогою команди:

```
python manage.py makemigrations
```

Ця команда аналізує ваші моделі та створює нові міграції для будь-яких змін, які вона виявить.

Після створення міграції ви можете застосувати її за допомогою команди:

```
python manage.py migrate
```

Ця команда застосовує всі незастосовані міграції до вашої бази даних.

#### Застосування та відкат міграцій.

Коли міграція застосована, зміни, описані в ній, застосовуються до бази даних. Якщо ви потім вирішите, що хочете відкатити зміни, ви можете це зробити за допомогою команди `migrate` з ім'ям додатку та попередньою версією міграції.

Наприклад:

```
python manage.py migrate myapp 0002_previous_migration
```



### Робота з базою даних через Django ORM

Django ORM (Object-Relational Mapping) - це міст між вашими моделями та базою даних. Завдяки ORM, вам не потрібно писати SQL-запити для взаємодії з базою даних: ви працюєте з вашими моделями як з звичайними Python-об'єктами.

#### Створення, вибірка, оновлення та видалення записів за допомогою ORM

Для додавання нового запису в базу даних використовуйте метод `create`:

```python
new_book = Book.objects.create(title="Нова книга", author="Автор")
```

Для вибірки даних використовуйте різні методи:

- `all()` - отримання всіх записів
- `get()` - отримання одного конкретного запису
- `filter()` - отримання записів, які відповідають певним критеріям
- `exclude()` - отримання записів, які не відповідають певним критеріям

```python
books = Book.objects.all()
specific_book = Book.objects.get(id=1)
filtered_books = Book.objects.filter(author="Автор")
```

Для оновлення записів можна використовувати метод `update`:

```python
Book.objects.filter(author="Автор").update(title="Нова назва")
```

Для видалення записів використовуйте метод `delete`:

```python
book_to_delete = Book.objects.get(id=2)
book_to_delete.delete()
```

#### Використання методів `filter`, `exclude`, `get`, `all` тощо

Як вже згадувалося вище, ці методи допомагають нам вибирати записи з бази даних:

- `all()` - отримання всіх записів
- `get()` - отримання одного конкретного запису
- `filter()` - отримання записів за певними критеріями
- `exclude()` - вибір записів, які не відповідають певним критеріям

#### Ланцюжкові запити до бази даних

Django ORM дозволяє робити ланцюжкові запити, що робить вибірку даних ще більш гнучкою:

```python
books = Book.objects.filter(author="Автор").exclude(title__contains="Стара").order_by("-publish_date")
```

У цьому прикладі ми отримали всі книги автора "Автор", виключивши ті, що містять слово "Стара" у назві, і відсортували їх за датою публікації у спадаючому порядку.



### Оптимізація запитів до бази даних

Оптимальність запитів до бази даних є критично важливою для продуктивності вашого веб-додатку. Django ORM надає ряд інструментів для оптимізації цих запитів.

#### Використання `select_related` та `prefetch_related` для зменшення кількості запитів

Обидва ці методи використовуються для оптимізації запитів, коли працюєте з зовнішніми ключами або зв'язками "багато до багатьох".

- `select_related` використовує SQL JOIN, тому він підходить для зв'язків ForeignKey та OneToOne. Він завантажує пов'язані об'єкти в одному запиті.

  ```python
  books = Book.objects.select_related('author').all()
  ```

- `prefetch_related`, в свою чергу, робить окремий запит для кожної відносини, але це відбувається оптимальним чином. Він корисний для зв'язків ManyToMany або коли у вас є багато об'єктів ForeignKey.

  ```python
  books = Book.objects.prefetch_related('authors').all()
  ```

#### Інші прийоми оптимізації: злиття запитів, використання `values` та `values_list`

- Замість отримання цілого об'єкта, якщо вам потрібно лише декілька полів, ви можете використовувати `values` або `values_list`. Це може зменшити обсяг завантажених даних.

  ```python
  authors_names = Book.objects.values_list('author__name', flat=True)
  ```

- Коли ви робите декілька запитів до однієї таблиці, Django може злити їх у один запит за допомогою кешування.

  ```python
  books = Book.objects.all()
  first_book = books[0]
  last_book = books[-1]
  ```

У цьому прикладі, незалежно від того, скільки разів ми звертаємося до `books`, реальний запит до бази даних буде зроблено лише один раз.



### Додаткові можливості моделей

#### Створення власних менеджерів та запитів

Менеджери моделі - це інтерфейс через який ви звертаєтесь до бази даних. Django моделі мають один за замовчуванням менеджер з ім'ям `objects`.

**Приклад:**

```python
books = Book.objects.all()
```

Але інколи може з'явитися потреба створити свій власний менеджер з додатковими методами.

**Приклад:**

```python
class PublishedBookManager(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(is_published=True)

class Book(models.Model):
    title = models.CharField(max_length=100)
    is_published = models.BooleanField(default=False)
    
    objects = models.Manager()  # Звичайний менеджер
    published = PublishedBookManager()  # Наш власний менеджер

# Використання власного менеджера
published_books = Book.published.all()
```

#### Оверрайдінг методів моделі: `save`, `delete` та інші

Моделі Django дозволяють перевизначити базові методи, що дає можливість змінити їх поведінку.

**Приклад з `save` методом:**

```python
class Book(models.Model):
    title = models.CharField(max_length=100)
    slug = models.SlugField(unique=True, blank=True)

    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.title)
        super().save(*args, **kwargs)
```

У цьому прикладі, перед зберіганням книги, ми генеруємо `slug` на основі її назви.

**Увага:** При оверрайдінгу методів завжди важливо викликати відповідний метод базового класу (`super().save(*args, **kwargs)`), щоб зберегти очікувану поведінку.
